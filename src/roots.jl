module Roots

using StaticArrays
using LinearAlgebra

export Root, isproportional, isorthogonal, ~, ‚üÇ

abstract type AbstractRoot{N,T} end

struct Root{N,T} <: AbstractRoot{N,T}
    coord::SVector{N,T}
end

Root(a) = Root(SVector(a...))

function Base.:(==)(r::Root{N}, s::Root{M}) where {M,N}
    M == N || return false
    r.coord == s.coord || return false
    return true
end

Base.hash(r::Root, h::UInt) = hash(r.coord, hash(Root, h))

Base.:+(r::Root{N,T}, s::Root{N,T}) where {N,T} = Root{N,T}(r.coord + s.coord)
Base.:-(r::Root{N,T}, s::Root{N,T}) where {N,T} = Root{N,T}(r.coord - s.coord)
Base.:-(r::Root{N}) where {N} = Root(-r.coord)

Base.:*(a::Number, r::Root) = Root(a * r.coord)
Base.:*(r::Root, a::Number) = a * r

Base.length(r::AbstractRoot) = norm(r, 2)

LinearAlgebra.norm(r::Root, p::Real=2) = norm(r.coord, p)
LinearAlgebra.dot(r::Root, s::Root) = dot(r.coord, s.coord)

cos_angle(a, b) = dot(a, b) / (norm(a) * norm(b))

function isproportional(Œ±::AbstractRoot{N}, Œ≤::AbstractRoot{M}) where {N,M}
    N == M || return false
    val = abs(cos_angle(Œ±, Œ≤))
    return isapprox(val, one(val), atol=eps(one(val)))
end

function isorthogonal(Œ±::AbstractRoot{N}, Œ≤::AbstractRoot{M}) where {N,M}
    N == M || return false
    val = cos_angle(Œ±, Œ≤)
    return isapprox(val, zero(val), atol=eps(one(val)))
end

function _positive_direction(Œ±::Root{N}) where {N}
    v = Œ±.coord + 1 / (N * 100) * rand(N)
    return Root{N,Float64}(v / norm(v, 2))
end

function positive(roots::AbstractVector{<:Root{N}}) where {N}
    # return those roots for which dot(Œ±, Root([¬Ω, ¬º, ‚Ä¶])) > 0.0
    pd = _positive_direction(first(roots))
    return filter(Œ± -> dot(Œ±, pd) > 0.0, roots)
end

function Base.show(io::IO, r::Root)
    print(io, "Root$(r.coord)")
end

function Base.show(io::IO, ::MIME"text/plain", r::Root{N}) where {N}
    lngth¬≤ = sum(x -> x^2, r.coord)
    l = isinteger(sqrt(lngth¬≤)) ? "$(sqrt(lngth¬≤))" : "‚àö$(lngth¬≤)"
    print(io, "Root in ‚Ñù^$N of length $l\n", r.coord)
end

ùïñ(N, i) = Root(ntuple(k -> k == i ? 1 : 0, N))
ùïÜ(N, ::Type{T}) where {T} = Root(ntuple(_ -> zero(T), N))

reflection(Œ±::Root, Œ≤::Root) = Œ≤ - Int(2dot(Œ±, Œ≤) / dot(Œ±, Œ±)) * Œ±
function cartan(Œ±, Œ≤)
    return [
        length(reflection(a, b) - b) / length(a) for a in (Œ±, Œ≤), b in (Œ±, Œ≤)
    ]
end

"""
    classify_root_system(Œ±, Œ≤)
Return the symbol of smallest system generated by roots `Œ±` and `Œ≤`.

The classification is based only on roots length,
proportionality/orthogonality and Cartan matrix.
"""
function classify_root_system(
    Œ±::AbstractRoot,
    Œ≤::AbstractRoot,
    long::Tuple{Bool,Bool},
)
    if isproportional(Œ±, Œ≤)
        if all(long)
            return :C‚ÇÅ
        elseif all(.!long) # both short
            return :A‚ÇÅ
        else
            @error "Proportional roots of different length"
            error("Unknown root system ‚ü®Œ±, Œ≤‚ü©:\n Œ± = $Œ±\n Œ≤ = $Œ≤")
        end
    elseif isorthogonal(Œ±, Œ≤)
        if all(long)
            return Symbol("C‚ÇÅ√óC‚ÇÅ")
        elseif all(.!long) # both short
            return Symbol("A‚ÇÅ√óA‚ÇÅ")
        elseif any(long)
            return Symbol("A‚ÇÅ√óC‚ÇÅ")
        end
    else # ‚ü®Œ±, Œ≤‚ü© is 2-dimensional, but they're not orthogonal
        a, b, c, d = abs.(cartan(Œ±, Œ≤))
        @assert a == d == 2
        b, c = b < c ? (b, c) : (c, b)
        if b == c == 1
            return :A‚ÇÇ
        elseif b == 1 && c == 2
            return :C‚ÇÇ
        elseif b == 1 && c == 3
            @warn ":G‚ÇÇ? really?"
            return :G‚ÇÇ
        else
            @error a, b, c, d
            error("Unknown root system ‚ü®Œ±, Œ≤‚ü©:\n Œ± = $Œ±\n Œ≤ = $Œ≤")
        end
    end
end

function proportional_root_from_system(Œ©::AbstractVector{<:Root}, Œ±::Root)
    k = findfirst(v -> isproportional(Œ±, v), Œ©)
    if isnothing(k)
        error("Line L_Œ± not contained in root system Œ©:\n Œ± = $Œ±\n Œ© = $Œ©")
    end
    return Œ©[k]
end

struct Plane{R<:Root}
    v1::R
    v2::R
    vectors::Vector{R}
end

Plane(Œ±::R, Œ≤::R) where {R<:Root} =
    Plane(Œ±, Œ≤, [a * Œ± + b * Œ≤ for a in -3:3 for b in -3:3])

function Base.in(r::R, plane::Plane{R}) where {R}
    return any(isproportional(r, v) for v in plane.vectors)
end

function _islong(Œ±::Root, Œ©)
    lŒ± = length(Œ±)
    return any(r -> lŒ± - length(r) > eps(lŒ±), Œ©)
end

function classify_sub_root_system(
    Œ©::AbstractVector{<:Root{N}},
    Œ±::Root{N},
    Œ≤::Root{N},
) where {N}
    @assert 1 ‚â§ length(unique(length, Œ©)) ‚â§ 2
    v = proportional_root_from_system(Œ©, Œ±)
    w = proportional_root_from_system(Œ©, Œ≤)

    subsystem = filter(œâ -> œâ in Plane(v, w), Œ©)
    @assert length(subsystem) > 0
    subsystem = positive(union(subsystem, -1 .* subsystem))

    l = length(subsystem)
    if l == 1
        x = first(subsystem)
        long = _islong(x, Œ©)
        return classify_root_system(x, -x, (long, long))
    elseif l == 2
        x, y = subsystem
        return classify_root_system(x, y, (_islong(x, Œ©), _islong(y, Œ©)))
    elseif l == 3
        x, y, z = subsystem
        l1, l2, l3 = _islong(x, Œ©), _islong(y, Œ©), _islong(z, Œ©)
        a = classify_root_system(x, y, (l1, l2))
        b = classify_root_system(y, z, (l2, l3))
        c = classify_root_system(x, z, (l1, l3))

        if :A‚ÇÇ == a == b == c # it's only A‚ÇÇ
            return a
        end

        throw("Unknown subroot system! $((x,y,z))")
    elseif l == 4
        subtypes = [
            classify_root_system(x, y, (_islong(x, Œ©), _islong(y, Œ©))) for
            x in subsystem for y in subsystem if x ‚â† y
        ]
        if :C‚ÇÇ in subtypes
            return :C‚ÇÇ
        end
    end
    @error "Unknown root subsystem generated by" Œ± Œ≤
    throw("Unknown root system: $subsystem")
end

end # of module Roots
