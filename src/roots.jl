module Roots

using StaticArrays
using LinearAlgebra

export Root, isproportional, isorthogonal, ~, ‚üÇ

abstract type AbstractRoot{N,T} end # <: AbstractVector{T} ?

‚Ñì‚ÇÇlength(r::AbstractRoot) = norm(r, 2)
ambient_dim(r::AbstractRoot) = length(r)
Base.:*(r::AbstractRoot, a::Number) = a * r

cos_angle(a, b) = dot(a, b) / (norm(a) * norm(b))

function isproportional(Œ±::AbstractRoot, Œ≤::AbstractRoot)
    ambient_dim(Œ±) == ambient_dim(Œ≤) || return false
    val = abs(cos_angle(Œ±, Œ≤))
    return isapprox(val, one(val); atol = eps(one(val)))
end

function isorthogonal(Œ±::AbstractRoot, Œ≤::AbstractRoot)
    ambient_dim(Œ±) == ambient_dim(Œ≤) || return false
    val = cos_angle(Œ±, Œ≤)
    return isapprox(val, zero(val); atol = eps(one(val)))
end

function positive(roots::AbstractVector{<:AbstractRoot})
    isempty(roots) && return empty(roots)
    pd = _positive_direction(first(roots))
    return filter(Œ± -> dot(Œ±, pd) > 0.0, roots)
end

function Base.show(io::IO, r::AbstractRoot)
    return print(io, "Root $(r.coord)")
end

function Base.show(io::IO, ::MIME"text/plain", r::AbstractRoot)
    l‚ÇÇl = ‚Ñì‚ÇÇlength(r)
    l = round(Int, l‚ÇÇl) ‚âà l‚ÇÇl ? "$(round(Int, l‚ÇÇl))" : "‚àö$(round(Int, l‚ÇÇl^2))"
    return print(io, "Root in ‚Ñù^$(length(r)) of length $l\n", r.coord)
end

function reflection(Œ±::AbstractRoot, Œ≤::AbstractRoot)
    return Œ≤ - Int(2dot(Œ±, Œ≤) // dot(Œ±, Œ±)) * Œ±
end
function cartan(Œ±::AbstractRoot, Œ≤::AbstractRoot)
    ambient_dim(Œ±) == ambient_dim(Œ≤) || throw("incompatible ambient dimensions")
    return [
        ‚Ñì‚ÇÇlength(reflection(a, b) - b) / ‚Ñì‚ÇÇlength(a) for a in (Œ±, Œ≤),
        b in (Œ±, Œ≤)
    ]
end

"""
    classify_root_system(Œ±, Œ≤)
Return the symbol of smallest system generated by roots `Œ±` and `Œ≤`.

The classification is based only on roots length,
proportionality/orthogonality and Cartan matrix.
"""
function classify_root_system(
    Œ±::AbstractRoot,
    Œ≤::AbstractRoot,
    long::Tuple{Bool,Bool},
)
    if isproportional(Œ±, Œ≤)
        if all(long)
            return :C‚ÇÅ
        elseif all(.!long) # both short
            return :A‚ÇÅ
        else
            @error "Proportional roots of different length"
            error("Unknown root system ‚ü®Œ±, Œ≤‚ü©:\n Œ± = $Œ±\n Œ≤ = $Œ≤")
        end
    elseif isorthogonal(Œ±, Œ≤)
        if all(long)
            return Symbol("C‚ÇÅ√óC‚ÇÅ")
        elseif all(.!long) # both short
            return Symbol("A‚ÇÅ√óA‚ÇÅ")
        elseif any(long)
            return Symbol("A‚ÇÅ√óC‚ÇÅ")
        end
    else # ‚ü®Œ±, Œ≤‚ü© is 2-dimensional, but they're not orthogonal
        a, b, c, d = abs.(cartan(Œ±, Œ≤))
        @assert a == d == 2
        b, c = b < c ? (b, c) : (c, b)
        if b == c == 1
            return :A‚ÇÇ
        elseif b == 1 && c == 2
            return :C‚ÇÇ
        elseif b == 1 && c == 3
            return :G‚ÇÇ
        else
            @error a, b, c, d
            error("Unknown root system ‚ü®Œ±, Œ≤‚ü©:\n Œ± = $Œ±\n Œ≤ = $Œ≤")
        end
    end
end

function proportional_root_from_system(
    Œ©::AbstractVector{<:AbstractRoot},
    Œ±::AbstractRoot,
)
    k = findfirst(v -> isproportional(Œ±, v), Œ©)
    if isnothing(k)
        error("Line L_Œ± not contained in root system Œ©:\n Œ± = $Œ±\n Œ© = $Œ©")
    end
    return Œ©[k]
end

struct Plane{R<:AbstractRoot}
    v1::R
    v2::R
    vectors::Vector{R}
end

function Plane(Œ±::AbstractRoot, Œ≤::AbstractRoot)
    return Plane(Œ±, Œ≤, [a * Œ± + b * Œ≤ for a in -3:3 for b in -3:3])
end

function Base.in(r::AbstractRoot, plane::Plane)
    return any(isproportional(r, v) for v in plane.vectors)
end

function _islong(Œ±::AbstractRoot, Œ©)
    lŒ± = ‚Ñì‚ÇÇlength(Œ±)
    return any(r -> lŒ± - ‚Ñì‚ÇÇlength(r) > eps(lŒ±), Œ©)
end

function classify_sub_root_system(
    Œ©::AbstractVector{<:AbstractRoot{N}},
    Œ±::AbstractRoot{N},
    Œ≤::AbstractRoot{N},
) where {N}
    @assert 1 ‚â§ length(unique(‚Ñì‚ÇÇlength, Œ©)) ‚â§ 2
    v = proportional_root_from_system(Œ©, Œ±)
    w = proportional_root_from_system(Œ©, Œ≤)

    subsystem = filter(œâ -> œâ in Plane(v, w), Œ©)
    @assert length(subsystem) > 0
    subsystem = positive(union(subsystem, -1 .* subsystem))

    l = length(subsystem)
    if l == 1
        x = first(subsystem)
        long = _islong(x, Œ©)
        return classify_root_system(x, -x, (long, long))
    elseif l == 2
        x, y = subsystem
        return classify_root_system(x, y, (_islong(x, Œ©), _islong(y, Œ©)))
    elseif l == 3
        x, y, z = subsystem
        l1, l2, l3 = _islong(x, Œ©), _islong(y, Œ©), _islong(z, Œ©)
        a = classify_root_system(x, y, (l1, l2))
        b = classify_root_system(y, z, (l2, l3))
        c = classify_root_system(x, z, (l1, l3))

        if :A‚ÇÇ == a == b == c # it's only A‚ÇÇ
            return a
        end

        throw("Unknown subroot system! $((x,y,z))")
    elseif l == 4
        subtypes = [
            classify_root_system(x, y, (_islong(x, Œ©), _islong(y, Œ©))) for
            x in subsystem for y in subsystem if x ‚â† y
        ]
        if :C‚ÇÇ in subtypes
            return :C‚ÇÇ
        end
        @warn subtypes
    elseif l == 6
        return :G‚ÇÇ
    end
    @error "Unknown root subsystem generated by" Œ± Œ≤ l
    throw("Unknown root system: $subsystem")
end

## concrete implementation:
struct Root{N,T} <: AbstractRoot{N,T}
    coord::SVector{N,T}
end

Root(a) = Root(SVector(a...))

# convienience constructors
ùïñ(N, i) = Root(ntuple(k -> k == i ? 1 : 0, N))
ùïÜ(N, ::Type{T}) where {T} = Root(ntuple(_ -> zero(T), N))

function Base.:(==)(r::Root{N}, s::Root{M}) where {M,N}
    M == N || return false
    r.coord == s.coord || return false
    return true
end

Base.hash(r::Root, h::UInt) = hash(r.coord, hash(Root, h))

function Base.:+(r::Root, s::Root)
    ambient_dim(r) == ambient_dim(s) || throw("incompatible ambient dimensions")
    return Root(r.coord + s.coord)
end

function Base.:-(r::Root, s::Root)
    ambient_dim(r) == ambient_dim(s) || throw("incompatible ambient dimensions")
    return Root(r.coord - s.coord)
end
Base.:-(r::Root) = Root(-r.coord)

Base.:*(a::Number, r::Root) = Root(a * r.coord)

Base.length(r::Root) = length(r.coord)

LinearAlgebra.norm(r::Root, p::Real = 2) = norm(r.coord, p)
LinearAlgebra.dot(r::Root, s::Root) = dot(r.coord, s.coord)

function _positive_direction(Œ±::Root{N}) where {N}
    v = Œ±.coord + 1 / (N * 100) * rand(N)
    return Root{N,Float64}(v / norm(v, 2))
end
end # of module Roots
