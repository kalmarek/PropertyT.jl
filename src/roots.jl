module Roots

using StaticArrays
using LinearAlgebra

export Root, isproportional, isorthogonal, ~, âŸ‚

abstract type AbstractRoot{N,T} end

struct Root{N,T} <: AbstractRoot{N,T}
    coord::SVector{N,T}
end

Root(a) = Root(SVector(a...))

function Base.:(==)(r::Root{N}, s::Root{M}) where {M,N}
    M == N || return false
    r.coord == s.coord || return false
    return true
end

Base.hash(r::Root, h::UInt) = hash(r.coord, hash(Root, h))

Base.:+(r::Root{N,T}, s::Root{N,T}) where {N,T} = Root{N,T}(r.coord + s.coord)
Base.:-(r::Root{N,T}, s::Root{N,T}) where {N,T} = Root{N,T}(r.coord - s.coord)
Base.:-(r::Root{N}) where {N} = Root(-r.coord)

Base.:*(a::Number, r::Root) = Root(a * r.coord)
Base.:*(r::Root, a::Number) = a * r

Base.length(r::AbstractRoot) = norm(r, 2)

LinearAlgebra.norm(r::Root, p::Real=2) = norm(r.coord, p)
LinearAlgebra.dot(r::Root, s::Root) = dot(r.coord, s.coord)

cos_angle(a, b) = dot(a, b) / (norm(a) * norm(b))

function isproportional(Î±::AbstractRoot{N}, Î²::AbstractRoot{M}) where {N,M}
    N == M || return false
    val = abs(cos_angle(Î±, Î²))
    return isapprox(val, one(val), atol=eps(one(val)))
end

function isorthogonal(Î±::AbstractRoot{N}, Î²::AbstractRoot{M}) where {N,M}
    N == M || return false
    val = cos_angle(Î±, Î²)
    return isapprox(val, zero(val), atol=eps(one(val)))
end

function _positive_direction(Î±::Root{N}) where {N}
    v = Î±.coord + 1 / (N * 100) * rand(N)
    return Root{N,Float64}(v / norm(v, 2))
end

function positive(roots::AbstractVector{<:Root{N}}) where {N}
    # return those roots for which dot(Î±, Root([Â½, Â¼, â€¦])) > 0.0
    pd = _positive_direction(first(roots))
    return filter(Î± -> dot(Î±, pd) > 0.0, roots)
end

function Base.show(io::IO, r::Root)
    print(io, "Root$(r.coord)")
end

function Base.show(io::IO, ::MIME"text/plain", r::Root{N}) where {N}
    lngthÂ² = sum(x -> x^2, r.coord)
    l = isinteger(sqrt(lngthÂ²)) ? "$(sqrt(lngthÂ²))" : "âˆš$(lngthÂ²)"
    print(io, "Root in â„^$N of length $l\n", r.coord)
end

ğ•–(N, i) = Root(ntuple(k -> k == i ? 1 : 0, N))
ğ•†(N, ::Type{T}) where {T} = Root(ntuple(_ -> zero(T), N))

"""
    classify_root_system(Î±, Î²)
Return the symbol of smallest system generated by roots `Î±` and `Î²`.

The classification is based only on roots length and
proportionality/orthogonality.
"""
function classify_root_system(Î±::AbstractRoot, Î²::AbstractRoot)
    lÎ±, lÎ² = length(Î±), length(Î²)
    if isproportional(Î±, Î²)
        if lÎ± â‰ˆ lÎ² â‰ˆ âˆš2
            return :Aâ‚
        elseif lÎ± â‰ˆ lÎ² â‰ˆ 2.0
            return :Câ‚
        else
            error("Unknown root system âŸ¨Î±, Î²âŸ©:\n Î± = $Î±\n Î² = $Î²")
        end
    elseif isorthogonal(Î±, Î²)
        if lÎ± â‰ˆ lÎ² â‰ˆ âˆš2
            return Symbol("Aâ‚Ã—Aâ‚")
        elseif lÎ± â‰ˆ lÎ² â‰ˆ 2.0
            return Symbol("Câ‚Ã—Câ‚")
        elseif (lÎ± â‰ˆ 2.0 && lÎ² â‰ˆ âˆš2) || (lÎ± â‰ˆ âˆš2 && lÎ² â‰ˆ 2)
            return Symbol("Aâ‚Ã—Câ‚")
        else
            error("Unknown root system âŸ¨Î±, Î²âŸ©:\n Î± = $Î±\n Î² = $Î²")
        end
    else # âŸ¨Î±, Î²âŸ© is 2-dimensional, but they're not orthogonal
        if lÎ± â‰ˆ lÎ² â‰ˆ âˆš2
            return :Aâ‚‚
        elseif (lÎ± â‰ˆ 2.0 && lÎ² â‰ˆ âˆš2) || (lÎ± â‰ˆ âˆš2 && lÎ² â‰ˆ 2)
            return :Câ‚‚
        else
            error("Unknown root system âŸ¨Î±, Î²âŸ©:\n Î± = $Î±\n Î² = $Î²")
        end
    end
end

function proportional_root_from_system(Î©::AbstractVector{<:Root}, Î±::Root)
    k = findfirst(v -> isproportional(Î±, v), Î©)
    if isnothing(k)
        error("Line L_Î± not contained in root system Î©:\n Î± = $Î±\n Î© = $Î©")
    end
    return Î©[k]
end

struct Plane{R<:Root}
    v1::R
    v2::R
    vectors::Vector{R}
end

Plane(Î±::R, Î²::R) where {R<:Root} =
    Plane(Î±, Î², [a * Î± + b * Î² for a in -3:3 for b in -3:3])

function Base.in(r::R, plane::Plane{R}) where {R}
    return any(isproportional(r, v) for v in plane.vectors)
end

function classify_sub_root_system(
    Î©::AbstractVector{<:Root{N}},
    Î±::Root{N},
    Î²::Root{N},
) where {N}

    v = proportional_root_from_system(Î©, Î±)
    w = proportional_root_from_system(Î©, Î²)

    subsystem = filter(Ï‰ -> Ï‰ in Plane(v, w), Î©)
    @assert length(subsystem) > 0
    subsystem = positive(union(subsystem, -1 .* subsystem))

    l = length(subsystem)
    if l == 1
        x = first(subsystem)
        return classify_root_system(x, x)
    elseif l == 2
        return classify_root_system(subsystem...)
    elseif l == 3
        a = classify_root_system(subsystem[1], subsystem[2])
        b = classify_root_system(subsystem[2], subsystem[3])
        c = classify_root_system(subsystem[1], subsystem[3])

        if a == b == c # it's only Aâ‚‚
            return a
        end

        C = (:Câ‚‚, Symbol("Câ‚Ã—Câ‚"))
        if (a âˆˆ C && b âˆˆ C && c âˆˆ C) && (:Câ‚‚ âˆˆ (a, b, c))
            return :Câ‚‚
        end
    elseif l == 4
        for i = 1:l
            for j = (i+1):l
                T = classify_root_system(subsystem[i], subsystem[j])
                T == :Câ‚‚ && return :Câ‚‚
            end
        end
    end
    @error "Unknown root subsystem generated by" Î± Î²
    throw("Unknown root system: $subsystem")
end

end # of module Roots
